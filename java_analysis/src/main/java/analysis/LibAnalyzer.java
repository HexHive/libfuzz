package analysis;

import com.google.common.collect.ImmutableList;
import sootup.core.model.SourceType;
import sootup.core.typehierarchy.ViewTypeHierarchy;
import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation;
import sootup.java.core.JavaProject;
import sootup.java.core.JavaSootClass;
import sootup.java.core.language.JavaLanguage;
import sootup.java.core.views.JavaView;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class LibAnalyzer {
    private static final JavaLanguage language = new JavaLanguage(8);
    private static final String objectName = "java.lang.Object";
    private final ClassLoader loader;
    private final JavaProject project;

    public LibAnalyzer(String libPath) {
        Path path = Paths.get(libPath);
        URL url;
        try {
            url = path.toUri().toURL();
        } catch (MalformedURLException e) {
            throw new RuntimeException(e);
        }

        loader = URLClassLoader.newInstance(new URL[] {url}, getClass().getClassLoader());

        project = JavaProject.builder(language).addInputLocation(new PathBasedAnalysisInputLocation(path, SourceType.Library)).build();
    }

    public ImmutableList<ApiInfo> extractAPIs() throws ClassNotFoundException {
        ImmutableList.Builder<ApiInfo> builder = new ImmutableList.Builder<>();
        for (JavaSootClass clazz: project.createFullView().getClasses()) {
            builder.addAll(extractApiFromClazz(clazz, loader));
        }
        return builder.build();
    }

    private ImmutableList<ApiInfo> extractApiFromClazz(JavaSootClass clazz, ClassLoader loader) throws ClassNotFoundException {
        if (!clazz.isPublic()) {
            return ImmutableList.of();
        }

        ImmutableList.Builder<ApiInfo> builder = ImmutableList.builder();
        Class<?> klazz = Class.forName(clazz.getName(), false, loader);

        // If a class is a generic class or an interface, we ignore it since we cannot implement it.
        if (klazz.isInterface() || klazz.getTypeParameters().length != 0) {
            return ImmutableList.of();
        }

        // We don't care private and protected methods of superclass, since it is not possible to call them
        Set<Method> methods = new HashSet<>();
        methods.addAll(List.of(klazz.getDeclaredMethods()));
        methods.addAll(Arrays.asList(klazz.getMethods()));
        for (Method method: methods) {
            if (method.isSynthetic()) {
                // We don't care method generated by compiler
                continue;
            }
            if (method.getDeclaringClass().getName().equals(objectName)) {
                // These are inherited from Object, I don't think we need to consider them
                continue;
            }

            Optional<ApiInfo> result = ApiInfo.buildApiInfo(method);

            // We ignore the API with complex generic types
            if (result.isPresent()) {
                // Declaring class of inherited methods is the inherited class. So the declaring class field
                // is set separately
                ApiInfo info = result.get();
                info.setDeclaringClazz(klazz);
                builder.add(info);
            }
        }

        for (Constructor<?> constructor: klazz.getDeclaredConstructors()) {
            Optional<ApiInfo> result = ApiInfo.buildApiInfo(constructor);
            if (result.isPresent()) {
                ApiInfo info = result.get();
                info.setDeclaringClazz(klazz);
                builder.add(info);
            }
        }

        return builder.build();
    }

    // The main point is to retrieve all subtype of a class and all implementer of a interface
    public Map<Arg, Set<Arg>> retrieveSubTypes() {
        JavaView view = project.createFullView();
        ViewTypeHierarchy hierarchy = new ViewTypeHierarchy(view);

        Map<Arg, Set<Arg>> subTypes = new HashMap<>();
        for (JavaSootClass sootClass: view.getClasses()) {
            // We don't care interface or abstract class since we cannot implement them
            subTypes.put(Arg.buildArg(sootClass.getType()),
                        hierarchy.subtypesOf(sootClass.getType()).stream().filter(classType -> view.getClass(classType).get().isConcrete()).map(Arg::buildArg).collect(Collectors.toSet()));
        }
        return subTypes;
    }
}
