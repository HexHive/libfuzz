package analysis;

import com.google.common.collect.ImmutableList;
import sootup.core.model.SourceType;
import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation;
import sootup.java.core.JavaProject;
import sootup.java.core.JavaSootClass;
import sootup.java.core.language.JavaLanguage;
import sootup.java.core.views.JavaView;

import java.io.IOException;
import java.lang.reflect.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Stream;

public class LibAnalyzer {
    private static final JavaLanguage language = new JavaLanguage(8);
    private static final String objectName = "java.lang.Object";
    private final ClassLoader loader;
    private final JavaProject project;
    private final JavaView view;
    private final List<Class<?>> clazzes;

    public LibAnalyzer(String libPath, String libName) throws ClassNotFoundException {
        Path path = Paths.get(libPath);
        URL[] urls;
        try (Stream<Path> s = Files.list(path)) {
            urls = s.map(p -> {
                try {
                    return p.toUri().toURL();
                } catch (MalformedURLException e) {
                    throw new RuntimeException(e);
                }
            }).toArray(URL[]::new);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        loader = URLClassLoader.newInstance(urls, getClass().getClassLoader());

        project = JavaProject.builder(language).addInputLocation(new PathBasedAnalysisInputLocation(Paths.get(libPath, libName), SourceType.Library)).build();

        view = project.createFullView();

        clazzes = new ArrayList<>();
        for (JavaSootClass sootClass: view.getClasses()) {
            if (sootClass.getName().startsWith("META-INF")) {
                // This is strange to me
                continue;
            }

//            String clazzName = sootClass.getName();
//            try {
//                loader.loadClass(clazzName);
//            } catch (ClassNotFoundException e) {
//                continue;
//            }

            Class<?> clazz = Class.forName(sootClass.getName(), false, loader);
            if (!clazz.isSynthetic()) {
                clazzes.add(clazz);
            }
        }
    }

    public ImmutableList<ApiInfo> extractAPIs() {
        ImmutableList.Builder<ApiInfo> builder = new ImmutableList.Builder<>();
        for (Class<?> clazz: clazzes) {
            builder.addAll(extractApiFromClazz(clazz));
        }
        return builder.build();
    }

    public static ImmutableList<ApiInfo> extractApiFromClazz(Class<?> klazz) {
        if (!Modifier.isPublic(klazz.getModifiers())) {
            return ImmutableList.of();
        }

        ImmutableList.Builder<ApiInfo> builder = ImmutableList.builder();

        // If a class is a generic class or an interface, we ignore it since we cannot implement it.
        if (klazz.isInterface() || klazz.getTypeParameters().length != 0) {
            return ImmutableList.of();
        }

        // We don't care private and protected methods of superclass, since it is not possible to call them
        Set<Method> methods = new HashSet<>();
        methods.addAll(List.of(klazz.getDeclaredMethods()));
        methods.addAll(Arrays.asList(klazz.getMethods()));
        for (Method method: methods) {
            if (method.isSynthetic()) {
                // We don't care method generated by compiler
                continue;
            }
            if (method.getDeclaringClass().getName().equals(objectName)) {
                // These are inherited from Object, I don't think we need to consider them
                continue;
            }

            Optional<ApiInfo> result = ApiInfo.buildApiInfo(method);

            // We ignore the API with complex generic types
            if (result.isPresent()) {
                // Declaring class of inherited methods is the inherited class. So the declaring class field
                // is set separately
                ApiInfo info = result.get();
                info.setDeclaringClazz(klazz);
                builder.add(info);
            }
        }

        for (Constructor<?> constructor: klazz.getDeclaredConstructors()) {
            Optional<ApiInfo> result = ApiInfo.buildApiInfo(constructor);
            if (result.isPresent()) {
                ApiInfo info = result.get();
                info.setDeclaringClazz(klazz);
                builder.add(info);
            }
        }

        return builder.build();
    }

    // The main point is to retrieve all subtype of a class and all implementer of an interface
    public Map<Arg, Set<Arg>> retrieveSubTypes() {

        Map<Class<?>, GenericType> mapping = new HashMap<>();
        Map<Arg, Set<Arg>> subtypeMap = new HashMap<>();

        for (Class<?> clazz: clazzes) {
            getGenericType(clazz, mapping);
        }

        for (Class<?> clazz: clazzes) {
            // We don't want to implement interface or generic class
            if (!clazz.isInterface() && clazz.getTypeParameters().length == 0) {
                GenericType type = mapping.get(clazz);
                for (Arg a: type.aliasToArgs()) {
                    if (!subtypeMap.containsKey(a)) {
                        subtypeMap.put(a, new HashSet<>());
                    }
                    subtypeMap.get(a).add(new Arg(clazz));
                }
            }
        }

        return subtypeMap;
    }

    // It looks this function works well on two test libraries, but I'm not sure if it is perfectly correct.
    private GenericType getGenericType(Class<?> clazz, Map<Class<?>, GenericType> mapping) {
        if (isBuiltInClass(clazz)) {
            return null;
        }

        if (mapping.containsKey(clazz)) {
            return mapping.get(clazz);
        }

        GenericType result = new GenericType(clazz.getName());

        Map<String, ImmutableList<String>> aliasMap = new HashMap<>();
        Map<String, ImmutableList<Integer>> indexMap = new HashMap<>();

        TypeVariable<?>[] typeVariables = clazz.getTypeParameters();

        buildTypeMap(clazz.getGenericSuperclass(), clazz.getSuperclass(), typeVariables, aliasMap, indexMap, mapping);

        Class<?>[] interfaces = clazz.getInterfaces();
        Type[] genericInterfaces = clazz.getGenericInterfaces();
        for (int i = 0; i < interfaces.length; i++) {
            buildTypeMap(genericInterfaces[i], interfaces[i], typeVariables, aliasMap, indexMap, mapping);
        }

        result.setAlias(aliasMap);
        result.setTypeIndex(indexMap);

        mapping.put(clazz, result);

        return result;
    }

    private void buildTypeMap(Type type, Class<?> clazz, TypeVariable<?>[] typeVariables,
                              Map<String, ImmutableList<String>> aliasMap,
                              Map<String, ImmutableList<Integer>> indexMap,
                              Map<Class<?>, GenericType> mapping) {
        if (clazz == null || clazz.getName().equals("java.lang.Object")) {
            return;
        }

        if (type instanceof ParameterizedType paramType) {
            GenericType genericType = getGenericType(clazz, mapping);
            Type[] typeArgs = paramType.getActualTypeArguments();

            if (genericType == null) {
                aliasMap.put(clazz.getName(),
                        Arrays.stream(typeArgs).map(Type::getTypeName).collect(ImmutableList.toImmutableList()));
                indexMap.put(clazz.getName(), ImmutableList.copyOf(retrieveIndex(typeVariables, typeArgs)));
            } else {
                aliasMap.putAll(genericType.fulfillAlias(typeArgs));
                indexMap.putAll(genericType.fulfillTypeIndex(retrieveIndex(typeVariables, typeArgs)));
            }
        } else {
            GenericType genericType = getGenericType(clazz, mapping);
            if (genericType == null) {
                aliasMap.put(clazz.getName(), ImmutableList.of());
                indexMap.put(clazz.getName(),
                        Arrays.stream(typeVariables).map(v -> GenericType.nonExistIdx).collect(ImmutableList.toImmutableList()));
            } else {
                aliasMap.putAll(genericType.fulfillAlias(new Type[]{}));
                indexMap.putAll(genericType.fulfillTypeIndex(Arrays.stream(typeVariables).map(v -> GenericType.nonExistIdx).toList()));
            }
        }
    }

    private ImmutableList<Integer> retrieveIndex(TypeVariable<?>[] typeParams, Type[] typeArgs) {
        ArrayList<Integer> result = new ArrayList<>();

        for (TypeVariable<?> v: typeParams) {
            int idx = GenericType.nonExistIdx;
            for (int i = 0; i < typeArgs.length; i++) {
                if (v.equals(typeArgs[i])) {
                    idx = i;
                }
            }
            result.add(idx);
        }

        return ImmutableList.copyOf(result);
    }

    private boolean isBuiltInClass(Class<?> clazz) {
        String clazzName = clazz.getName();
        return clazzName.startsWith("java.") || clazzName.startsWith("com.sun.") || clazzName.startsWith("com.oracle.");
    }
}
